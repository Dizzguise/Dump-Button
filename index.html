<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Streaming Control Panel</title>
    <style>
        body {
            background-color: #333333;
            color: #FFFFFF;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            width: 80%;
            margin-bottom: 20px;
        }
        .button {
            background-color: #555555;
            color: #FFFFFF;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            cursor: pointer;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <h2>Streaming Control Panel</h2>
    <div class="controls">
        <div class="control-group">
            <button class="button" onclick="startYoutube()">Start YouTube</button>
            <button class="button" onclick="dumpYoutube()">Dump YouTube</button>
            <button class="button" onclick="stopYoutube()">Stop YouTube</button>
        </div>
        <div class="control-group">
            <button class="button" onclick="startRumble()">Start Rumble</button>
            <button class="button" onclick="dumpRumble()">Dump Rumble</button>
            <button class="button" onclick="stopRumble()">Stop Rumble</button>
        </div>
    </div>
    <button class="button" onclick="stopAllStreams()">Stop All Streams</button>
    <script>
        /* note, it's normally expected to use a bundler to build this file, but I woke up to day and chose violence */
        /* Complete promise.rpc.protocol file */
        const PromiseRPCProtocol = (function() {
            var NOP = function () {};

            function randomId() {
            return (((1 << 24) * Math.random()) | 0).toString(16);
            }

            function PromiseRPCProtocol(handler) {
            var self = this;

            self.requests = {};
            self.TIMEOUT = 5000;

            self.onMessage = NOP;
            self.onDispatch = NOP;

            if (typeof handler !== "function") {
                var fns = handler;
                self.handler = function (req) {      
                if (typeof fns[req.name] === "function" && req.args !== null) {
                    var result = fns[req.name].apply(self, req.args);
                    return result;
                } else {
                    self.onMessage("error", { type: "badrequest", req: req });
                }
                };
            } else {
                self.handler = handler;
            }
            }

            PromiseRPCProtocol.prototype.destroy = function () {
            var self = this;

            self._write = NOP;
            self.onMessage = NOP;
            self.onDispatch = NOP;

            delete self.handler;
            Object.keys(self.requests).forEach(function (key) {
                self.requests[key].reject("destroyed");
                clearTimeout(self.requests[key].handle);
                delete self.requests[key];
            });

            delete self.requests;
            };

            PromiseRPCProtocol.prototype.randomId = randomId;

            PromiseRPCProtocol.prototype.validateId = function (id) {
            return !!this.requests[id];
            };

            PromiseRPCProtocol.prototype.dispatch = function (buffer) {
            var self = this;

            if (buffer.action) {
                var action = buffer.action;
                var id = buffer.id;
                var value = buffer.value;
                var reason = buffer.reason;

                if (action === "execute") {
                self.handler &&
                    typeof self.handler === "function" &&
                    self.handler(buffer);
                } else if (action === "request") {
                if (self.handler && typeof self.handler === "function") {
                    Promise.resolve(this.handler(buffer))
                    .then(function (value) {
                        self.resolve(id, value);
                    })
                    .catch(function (reason) {
                        self.reject(id, reason);
                    });
                }
                } else if (action === "resolve") {
                if (self.validateId(id)) {
                    clearTimeout(self.requests[id].handle);
                    self.requests[id].resolve(value);
                    delete self.requests[id];
                }
                } else if (action === "reject" && self.validateId(id)) {
                clearTimeout(self.requests[id].handle);
                self.requests[id].reject(reason);
                delete self.requests[id];
                }
            }
            };

            // an 'execute' does not expect any result
            PromiseRPCProtocol.prototype.execute = function (fn, args) {
            this.onDispatch({ action: "execute", name: fn, args: args });
            };

            PromiseRPCProtocol.prototype.createRequest = function () {
            var self = this;

            var id = self.randomId();

            var requests = self.requests;
            var request = (self.requests[id] = {});

            request.handle = setTimeout(function () {
                request.reject("timeout");
                delete requests[id];
            }, self.TIMEOUT);

            return {
                promise: new Promise(function (resolve, reject) {
                Object.assign(request, { resolve: resolve, reject: reject });
                }),
                id: id,
            };
            };

            // a 'request' expects a response from the server, and will return that to you as a promise, note this promise can fail due to timeout
            PromiseRPCProtocol.prototype.request = function (fn, args) {
            var request = this.createRequest();
            // TODO: forward timeout for id to opposite end?
            this.onDispatch({ action: "request", id: request.id, name: fn, args: args });
            return request.promise;
            };

            PromiseRPCProtocol.prototype.resolve = function (id, value) {
            this.onDispatch({ action: "resolve", id: id, value: value });
            };

            PromiseRPCProtocol.prototype.reject = function (id, reason) {
            this.onDispatch({ action: "reject", id: id, reason: reason });
            };
            
            return PromiseRPCProtocol;
        })();
    </script>
    <script>
        const rpcConn = new PromiseRPCProtocol();
        rpcConn.onDispatch = (message) => {
            console.log({rpc: message});
            electronAPI.sendMessage('rpc', message);
        };

        electronAPI.receiveMessage('rpc', (event, arg) => {
            rpcConn.dispatch(arg);
        });

         function startYoutube() {
            rpcConn.request('startYoutube');
            toggleButtons('youtube', true);
        }

        function stopYoutube() {
            rpcConn.request('stopYoutube');
            toggleButtons('youtube', false);
        }

        function dumpYoutube() {
            rpcConn.request('dumpYoutube');
            toggleButtons('youtube', 'dump');
        }

        function resumeYoutube() {
            rpcConn.request('startYoutube');
            toggleButtons('youtube', true);
        }

        function startRumble() {
            rpcConn.request('startRumble');
            toggleButtons('rumble', true);
        }

        function stopRumble() {
            rpcConn.request('stopRumble');
            toggleButtons('rumble', false);
        }

        function dumpRumble() {
            rpcConn.request('dumpRumble');
            toggleButtons('rumble', 'dump');
        }

        function resumeRumble() {
            rpcConn.request('startRumble');
            toggleButtons('rumble', true);
        }

        function stopAllStreams() {
            stopYoutube();
            stopRumble();
        }

        function toggleButtons(stream, mode) {
        const startButton = document.querySelector(`button[data-stream="${stream}"][data-mode="start"]`);
        const stopButton = document.querySelector(`button[data-stream="${stream}"][data-mode="stop"]`);
        const dumpButton = document.querySelector(`button[data-stream="${stream}"][data-mode="dump"]`);

        if (mode === true) {
            // Stream is active, hide start button, show stop button
            startButton.style.display = 'none';
            stopButton.style.display = 'inline-block';
            dumpButton.style.display = 'none'; // Hide dump button when streaming
        } else if (mode === false) {
            // Stream is stopped, hide stop button, show start button
            startButton.style.display = 'inline-block';
            stopButton.style.display = 'none';
            dumpButton.style.display = 'none'; // Hide dump button when stopped
        } else if (mode === 'dump') {
            // Stream is being dumped, hide both start and stop buttons, show dump button
            startButton.style.display = 'none';
            stopButton.style.display = 'none';
            dumpButton.style.display = 'inline-block';
        }
    }
    </script>
</body>
</html>